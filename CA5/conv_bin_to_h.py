import struct
import os

# --- Settings ---
NUM_IMAGES_TO_CONVERT = 3  # Set the number of images you want to embed
IMAGE_CHANNELS = 3
IMAGE_HEIGHT = 32
IMAGE_WIDTH = 32
INPUT_SIZE = IMAGE_CHANNELS * IMAGE_HEIGHT * IMAGE_WIDTH

# --- File Paths ---
IMAGES_BIN_FILE = "cifar10_test_images.bin"
LABELS_BIN_FILE = "cifar10_test_labels.bin"
OUTPUT_HEADER_FILE = "test_images.h"

def convert_images_to_c_header():
    """
    Reads a specified number of images and labels from binary files
    and saves them into a C header file.
    """
    if not os.path.exists(IMAGES_BIN_FILE) or not os.path.exists(LABELS_BIN_FILE):
        print(f"Error: Input files '{IMAGES_BIN_FILE}' or '{LABELS_BIN_FILE}' not found.")
        return

    all_images_data = []
    all_labels_data = []

    # Read image and label data from the binary files
    with open(IMAGES_BIN_FILE, "rb") as f_images, open(LABELS_BIN_FILE, "rb") as f_labels:
        for i in range(NUM_IMAGES_TO_CONVERT):
            # Read one image (each float is 4 bytes)
            image_bytes = f_images.read(INPUT_SIZE * 4)
            if len(image_bytes) != INPUT_SIZE * 4:
                print(f"Error: Image file is not large enough to read image #{i+1}.")
                return
            all_images_data.append(struct.unpack(f"{INPUT_SIZE}f", image_bytes))

            # Read one label (int32_t is 4 bytes)
            label_byte = f_labels.read(4)
            if len(label_byte) != 4:
                print(f"Error: Label file is not large enough to read label #{i+1}.")
                return
            all_labels_data.append(struct.unpack("i", label_byte)[0])

    # Write the data into the C header file
    with open(OUTPUT_HEADER_FILE, "w") as f:
        f.write(f"// This file is auto-generated by a Python script.\n")
        f.write(f"// It contains {NUM_IMAGES_TO_CONVERT} test images and their labels.\n\n")
        f.write("#ifndef TEST_IMAGES_H\n")
        f.write("#define TEST_IMAGES_H\n\n")
        f.write("#include <stdint.h>\n\n")

        # Define the number of images as a macro for the C code to use
        f.write(f"// The number of test images stored in this file\n")
        f.write(f"#define NUM_TEST_IMAGES {NUM_IMAGES_TO_CONVERT}\n\n")

        # Write the image data array
        f.write(f"// Image data with dimensions [NUM_TEST_IMAGES][{IMAGE_CHANNELS}][{IMAGE_HEIGHT}][{IMAGE_WIDTH}]\n")
        f.write(f"const float test_images_data[NUM_TEST_IMAGES][{IMAGE_CHANNELS}][{IMAGE_HEIGHT}][{IMAGE_WIDTH}] = {{\n")
        
        for i, image_data in enumerate(all_images_data):
            f.write("  {\n") # Start of image i
            for c in range(IMAGE_CHANNELS):
                f.write("    {\n") # Start of channel c
                for h in range(IMAGE_HEIGHT):
                    f.write("      {") # Start of row h
                    for w in range(IMAGE_WIDTH):
                        index = c * (IMAGE_HEIGHT * IMAGE_WIDTH) + h * IMAGE_WIDTH + w
                        f.write(f"{image_data[index]:.8f}f")
                        if w < IMAGE_WIDTH - 1:
                            f.write(", ")
                    f.write("}")
                    if h < IMAGE_HEIGHT - 1:
                        f.write(",\n")
                f.write("\n    }") # End of channel c
                if c < IMAGE_CHANNELS - 1:
                    f.write(",\n")
            f.write("\n  }") # End of image i
            if i < NUM_IMAGES_TO_CONVERT - 1:
                f.write(",\n")
        f.write("\n};\n\n")

        # Write the label data array
        f.write("// Ground truth labels for the images\n")
        f.write(f"const int32_t test_image_labels[NUM_TEST_IMAGES] = {{")
        f.write(", ".join(map(str, all_labels_data)))
        f.write("};\n\n")

        f.write("#endif // TEST_IMAGES_H\n")

    print(f"Header file '{OUTPUT_HEADER_FILE}' was successfully created for {NUM_IMAGES_TO_CONVERT} images.")


if __name__ == "__main__":
    convert_images_to_c_header()